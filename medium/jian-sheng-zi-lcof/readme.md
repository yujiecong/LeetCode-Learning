#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

**提示：**

- `2 <= n <= 58`



```
class Solution:
    def cuttingRope(self, n: int) -> int:
        l=n #用 l来作为绳子长度
        dp=[0]*(l+1)
        dp[2]=1
        for i in range(3,l+1):
            for j in range(2,i//2+2): #+2是为了适应 n=3时
                # print(dp[j],dp[i-j])
                # print(i,j)
                dp[i]=(max(dp[i],max(j*(i-j),j*dp[i-j])))
        print(dp)
        return dp[l]
```

![1618308456600](readme.assets/1618308456600.png)

这道题有两种理解,第一种就是 直接像上面这样

这题用动态规划是比较好理解的

    我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来
    用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1
    我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪
    剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])
    第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为
    dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
    最后返回dp[n]即可

```
作者：edelweisskoko
链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-huan-s-xopj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

或者

```
思路:
1.首先我们考虑这道题，感觉十分的复杂，因为不知道，我们要到底要分成几段才能保证乘积最大
2.然后我们仔细一想，为什么会有三段或者更多的段数，三段就是由两段再分解而来（其中一段分成两段）我们就使用这个特点来编程。
3.我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的两条绳子转移而来
4.用一个nums数组记录从0到n长度的绳子剪掉后的最大乘积，也就是nums[i]表示长度为i的绳子剪成m段后的最大乘积，初始化nums[1] = 1.
5.我们先把绳子a 剪掉第一段b（长度为j）,那么剩下的绳子c 长度就为（i-j）,然后我们再来判断下第一段绳子b的本身的长度和若它为剪绳，它的乘积的值，取最大值为nums[j],同理，绳长为（i-j）的绳子c,比较（它本身的长度和作为剪绳它的乘积的值），取其中的最大值为nums[i - j]，最后可以得到绳子a 的乘积为nums[ j]*nums[i - j].同理，求绳子b作为剪绳它的乘积的值，也是同样的方法。
6.举个例子来理解吧，我们求剪绳子z（长度为3）nums[3]的最大乘积：它可以分成一条是x(长度为1)nums[1]，一条是y（(长度为2)）,而绳子y可以再分成两条绳子长度分别为:1,1，绳子（z）剪绳子的情况就这两种（两条 1乘2（为y绳长为2，本身的绳长）,三条 1乘1乘1（其中1乘1是如果绳子y是剪绳的最大乘积的值）），所以我们可以就留下最大为nums[2]，最后让nums[1]*nums[2]求出nums[3]的值。

作者：wu-ming-ft
链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-1jian-sheng-zi-shi-yon-lmdz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

